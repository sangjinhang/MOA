<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>ğŸš€ å°å¯ä¹å•è¯æ¶ˆæ¶ˆä¹ ğŸš€</title>
  <style>
    /* ====== å…¨å±€æ ·å¼ ====== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: "Comic Sans MS", cursive, sans-serif;
      background: linear-gradient(to right, #4facfe, #00f2fe);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0 auto;
      padding: 10px;
      text-align: center;
    }
    h1, h2, h3 {
      margin: 5px 0;
    }

    /* ====== åŠŸèƒ½æŒ‰é’® ====== */
    .buttons {
      margin: 10px 0;
    }
    .btn {
      padding: 8px 15px;
      border: none;
      border-radius: 8px;
      margin: 0 5px;
      cursor: pointer;
      font-size: 16px;
    }
    .btn-upload {
      background: #ff9800;
      color: #fff;
    }
    .btn-start {
      background: #4caf50;
      color: #fff;
    }

    /* ====== å®¹å™¨ & ç½‘æ ¼å¸ƒå±€ï¼ˆå§‹ç»ˆ 4Ã—4ï¼‰ ====== */
    .container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
      max-width: 1200px;
      margin-top: 10px;
    }
    .game-board {
      /* å›ºå®šä¸º 4 åˆ—ç½‘æ ¼ï¼ˆ16 å¼ å¡ï¼‰ */
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      width: 95vw;
      max-width: 600px;
      margin: 0 auto;
      background: #2196f3;
      padding: 20px;
      border-radius: 20px;
      box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);
      min-height: 460px;
      flex-shrink: 0;
    }

    /* ====== å•å¼ å¡ç‰‡ ====== */
    .card {
      background: #ffeb3b;
      color: #222;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      border: 4px solid #fbc02d;
      transition: transform 0.2s, background 0.3s;
      box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.2);
      aspect-ratio: 1 / 1; /* ä¿æŒå¡ç‰‡æ­£æ–¹å½¢ */
      position: relative;  /* æ–¹ä¾¿åŠ ç‰¹æ•ˆ */
    }
    .card:hover {
      transform: scale(1.05);
    }
    .card.selected {
      background: #ff9800;
      transform: scale(1.1);
    }
    .matched {
      background: #4caf50;
      pointer-events: none;
      animation: fadeOut 0.4s forwards;
    }
    .wrong {
      background: red !important;
      animation: shake 0.3s;
    }
    @keyframes fadeOut {
      100% {
        opacity: 0;
        visibility: hidden;
        transform: scale(0.8);
      }
    }
    @keyframes shake {
      0%   { transform: translateX(0); }
      25%  { transform: translateX(-5px); }
      50%  { transform: translateX(5px); }
      75%  { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }

    /* ====== æ’è¡Œæ¦œåŒº ====== */
    .leaderboard {
      background: #ffffff;
      color: #222;
      padding: 15px;
      border-radius: 15px;
      width: 250px;
      box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.3);
      margin-left: 20px;
      text-align: left;
      height: fit-content;
    }
    .leaderboard h2 {
      text-align: center;
      color: #ff4081;
    }
    .leaderboard ul {
      list-style: none;
      padding: 0;
    }
    .leaderboard li {
      font-size: 2-px;
      padding: 5px 0;
    }
    @media (max-width: 600px) {
      .leaderboard {
        display: none; /* å°å±å¯éšè—æ’è¡Œæ¦œ */
      }
    }

    /* ====== ç»“æŸç•Œé¢ï¼ˆé”™è¯¯æ±‡æ€»ï¼‰ ====== */
    #endScreen {
      display: none;
      position: fixed;
      z-index: 999;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      color: #222;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
      text-align: left;
    }
    #endScreen h2 {
      text-align: center;
      color: #2196f3;
    }
    #wrongWordSummary table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    #wrongWordSummary th, #wrongWordSummary td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    #endCloseBtn {
      background-color: #f44336;
      color: #fff;
      border: none;
      padding: 8px 16px;
      margin-top: 10px;
      cursor: pointer;
      border-radius: 5px;
      float: right;
    }
  </style>
</head>
<body>
  <h1>ğŸš€ å°å¯ä¹å•è¯æ¶ˆæ¶ˆä¹ ğŸš€</h1>
  
  <div class="buttons">
    <!-- Excel æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="excelFile" accept=".xls,.xlsx" class="btn btn-upload" />
    <!-- å¼€å§‹æ¸¸æˆæŒ‰é’® -->
    <button id="startBtn" class="btn btn-start" disabled>å¼€å§‹æ¸¸æˆ</button>
    <!-- æç¤ºæŒ‰é’® -->
    <button id="hintBtn" class="btn" disabled>æç¤º(2)</button>
	  <!-- ä¸‹è½½æ–‡ä»¶æŒ‰é’® -->
  <button id="downloadFileBtn" class="btn btn-upload">ä¸‹è½½å•è¯æ¨¡æ¿</button>
  </div>

  <h2>å…³å¡: <span id="level">1</span></h2>
  <h2>æ—¶é—´: <span id="timer">0.00</span> ç§’</h2>
  <h3>âœ… å·²åŒ¹é…æˆåŠŸï¼š<span id="matchedCount">0</span> ç»„å•è¯</h3>
  
  <!-- æ˜¾ç¤ºç”Ÿå‘½ä¸è¿å‡» -->
  <h3>â¤ï¸ ç”Ÿå‘½: <span id="livesDisplay">3</span> | ğŸ”¥ è¿å‡»: <span id="comboDisplay">0</span></h3>

  <div class="container">
    <div class="game-board" id="gameBoard">
      <!-- æœªå¼€å§‹æ¸¸æˆæ—¶ï¼Œè¿™é‡Œä¸ºç©ºï¼›ç‚¹å‡»å¼€å§‹åç”Ÿæˆ16å¼ å¡ç‰‡ -->
	ä¸‹è½½æ¨¡æ¿åæ·»åŠ å•è¯å†ä¸Šä¼ ï¼Œç‚¹å‡»å¼€å§‹æ¸¸æˆ
    </div>
    <div class="leaderboard">
      <h2>ğŸ–ï¸ æ’è¡Œæ¦œ ğŸ–ï¸</h2>
      <ul id="leaderboardList"></ul>
    </div>
  </div>

  <!-- ç»“æŸç•Œé¢ï¼ˆæ˜¾ç¤ºæ‰€æœ‰é”™è¯¯çš„å•è¯ï¼‰ -->
  <div id="endScreen">
    <h2>æ¸¸æˆç»“æŸ</h2>
    <p>ä»¥ä¸‹æ˜¯æ‰€æœ‰å…³å¡ä¸­é”™è¯¯åŒ¹é…çš„è®°å½•ï¼Œå¤ä¹ ä¸€ä¸‹å§ï¼</p>
    <div id="wrongWordSummary"></div>
    <button id="endCloseBtn">å…³é—­</button>
  </div>
  
  <!-- éŸ³æ•ˆæ–‡ä»¶ -->
  <audio id="matchSound" src="1.MP3"></audio>
  <audio id="wrongSound" src="2.MP3"></audio>
  
  <!-- SheetJS ç”¨äºå‰ç«¯è§£æ Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script>
    // ====== å…¨å±€å˜é‡ ======
    let allWords = [];              // Excel å¯¼å…¥åå­˜æ”¾ {en, cn} çš„æ•°ç»„
    let usedWords = [];             // å·²ä½¿ç”¨è¿‡çš„â€œè‹±æ–‡â€å•è¯
    let currentWords = [];          // å½“å‰å…³å¡é€‰å‡ºçš„ 8 ç»„å•è¯
    let cards = [];                 // æœ¬å…³16å¼ å¡ç‰‡
    let flippedCards = [];          // å·²ç¿»å¼€çš„å¡ç‰‡DOM

    let timer = 0.00;               // è®¡æ—¶
    let timerInterval = null;
    let level = 1;                  // å…³å¡æ•°
    let matchedCount = 0;           // ç´¯è®¡åŒ¹é…æˆåŠŸ

    let leaderboard = [];           // è®°å½•å„å…³ { time, mistakes, maxCombo }
    let mistakesThisRound = 0;      // æœ¬å…³é”™è¯¯æ¬¡æ•°

    let wrongMatches = {};          // wrongMatches[level] = [ { card1, card2 }, ...]

    // ====== æ–°å¢åŠŸèƒ½ç›¸å…³å˜é‡ ======
    let combo = 0;                  // å½“å‰è¿å‡»æ•°
    let maxCombo = 0;               // æœ¬å…³æœ€é«˜è¿å‡»

    let lives = 3;                  // å½“å‰å‰©ä½™ç”Ÿå‘½
    const initialLives = 3;         // æ¯å…³åˆå§‹ç”Ÿå‘½

    let hintCount = 2;              // æœ¬å…³å‰©ä½™æç¤ºæ¬¡æ•°
    const initialHintCount = 2;     // æ¯å…³åˆå§‹æç¤ºæ¬¡æ•°

    // æ ‡è®°æ˜¯å¦â€œæœ€åä¸€å±€â€ï¼ˆå½“æœªä½¿ç”¨å•è¯ä¸è¶³8ç»„æ—¶ï¼‰ï¼Œè¿™å±€ç»“æŸåå°± game over
    let isFinalRound = false;

    // ====== è§£æ Excel æ–‡ä»¶ ======
    const fileInput = document.getElementById("excelFile");
    const startBtn  = document.getElementById("startBtn");
    const hintBtn   = document.getElementById("hintBtn");

    fileInput.addEventListener("change", handleFile, false);
    startBtn.addEventListener("click", createGameBoard);
    hintBtn.addEventListener("click", useHint);

    // è¯»Excel
    function handleFile(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(evt) {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        // åˆå§‹åŒ–
        allWords = [];
        usedWords = [];
        matchedCount = 0;
        level = 1;
        leaderboard = [];
        mistakesThisRound = 0;
        wrongMatches = {};
        isFinalRound = false;

        document.getElementById("matchedCount").innerText = "0";
        document.getElementById("level").innerText = "1";

        for (let i = 0; i < jsonData.length; i++) {
          const row = jsonData[i];
          if (row[0] && row[1]) {
            allWords.push({ en: row[0], cn: row[1] });
          }
        }
        alert("Excel å¯¼å…¥æˆåŠŸï¼å…± " + allWords.length + " æ¡å•è¯ã€‚");
        startBtn.disabled = false;
      };
      reader.readAsArrayBuffer(file);
    }

    // ====== å¼€å§‹/åˆ›å»ºå…³å¡ (å›ºå®š 16 å¼ å¡) ======
    function createGameBoard() {
      // è‹¥è¯åº“ä¸ºç©º
      if (allWords.length === 0) {
        alert("è¯·å…ˆå¯¼å…¥å«æœ‰å•è¯çš„ Excel æ–‡ä»¶ï¼");
        return;
      }

      const gameBoard = document.getElementById("gameBoard");
      gameBoard.innerHTML = "";

      // é‡ç½®æœ¬å…³æ•°æ®
      mistakesThisRound = 0;
      wrongMatches[level] = [];

      // é‡ç½®ç”Ÿå‘½ & è¿å‡» & æç¤º
      lives = initialLives;
      document.getElementById("livesDisplay").innerText = lives;

      combo = 0;
      maxCombo = 0;
      document.getElementById("comboDisplay").innerText = combo;

      hintCount = initialHintCount;
      hintBtn.innerText = `æç¤º(${hintCount})`;
      hintBtn.disabled = false;

      // æ¯å…³éœ€è¦ 8 ç»„(=16å¼ )
      const needed = 8;
      // ä»æœªä½¿ç”¨çš„è‹±æ–‡å•è¯é‡Œå–
      let unused = allWords.filter(w => !usedWords.includes(w.en));

      // åˆ¤æ–­æ˜¯å¦è¿˜å¤Ÿ 8 ç»„
      if (unused.length < needed) {
        // ä¸è¶³8ç»„ -> æœ€åä¸€å±€: ç”¨å·²ç”¨è¿‡çš„æ¥è¡¥è¶³ï¼Œå®Œæˆåæ¸¸æˆç»“æŸ
        isFinalRound = true;

        // å…ˆæ‹¿æ‰€æœ‰â€œæœªä½¿ç”¨â€çš„
        let finalWords = [...unused];
        // è¿˜éœ€è¦å¤šå°‘
        let stillNeed = needed - finalWords.length;
        // ä»å·²ä½¿ç”¨çš„å•è¯ä¸­éšæœºè¡¥è¶³
        let usedPool = allWords.filter(w => usedWords.includes(w.en));
        shuffle(usedPool);

        // è¿‡æ»¤ï¼šä¸è¦è·Ÿ finalWords é‡Œé‡å¤è‹±æ–‡
        usedPool = usedPool.filter(w => !finalWords.some(fw => fw.en === w.en));

        let fill = usedPool.slice(0, stillNeed);
        finalWords.push(...fill);

        currentWords = finalWords;
      } else {
        // æ­£å¸¸æƒ…å†µï¼šæœªä½¿ç”¨å•è¯è¶³å¤Ÿ -> æŠ½8ç»„
        shuffle(unused);
        currentWords = unused.slice(0, needed);
      }
      // æŠŠæ­¤æ¬¡å…³å¡çš„è‹±æ–‡è®°ä¸ºå·²ç”¨
      usedWords.push(...currentWords.map(word => word.en));

      // ç”Ÿæˆ16å¼ å¡ç‰‡ (ä¸­è‹±å„ä¸€å¼ )
      cards = [];
      currentWords.forEach(word => {
        cards.push({ text: word.en, pair: word.cn });
        cards.push({ text: word.cn, pair: word.en });
      });
      shuffle(cards);

      // æ¸²æŸ“å¡ç‰‡
      cards.forEach(card => {
        const cardElement = document.createElement("div");
        cardElement.classList.add("card");
        cardElement.dataset.text = card.text;
        cardElement.dataset.pair = card.pair;
        cardElement.innerText = card.text;
        cardElement.addEventListener("click", flipCard);
        gameBoard.appendChild(cardElement);
      });

      // è®¡æ—¶å™¨é‡ç½®
      timer = 0.00;
      clearInterval(timerInterval);
      startTimer();
    }

    // ====== è®¡æ—¶å™¨ ======
    function startTimer() {
      document.getElementById("timer").innerText = timer.toFixed(2);
      timerInterval = setInterval(() => {
        timer += 0.01;
        document.getElementById("timer").innerText = timer.toFixed(2);
      }, 10);
    }

    // ====== æ´—ç‰Œ ======
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // ====== ç¿»ç‰Œ ======
    function flipCard() {
      if (flippedCards.length === 2) return; // ç­‰å¾…æ£€æŸ¥
      if (this.classList.contains("matched")) return;

      this.classList.add("selected");
      flippedCards.push(this);

      if (flippedCards.length === 2) {
        setTimeout(checkMatch, 400);
      }
    }

    // ====== æ£€æŸ¥åŒ¹é… ======
    function checkMatch() {
      const [card1, card2] = flippedCards;
      const matchSound = document.getElementById("matchSound");
      const wrongSound = document.getElementById("wrongSound");

      if (card1.dataset.text === card2.dataset.pair) {
        // ---- æˆåŠŸåŒ¹é… ----
        card1.classList.add("matched");
        card2.classList.add("matched");
        matchSound.play();

        // è¿å‡» +1
        combo++;
        if (combo > maxCombo) {
          maxCombo = combo;
        }
        document.getElementById("comboDisplay").innerText = combo;

        // å‘éŸ³
        let englishText = "";
        if (currentWords.some(w => w.en === card1.dataset.text)) {
          englishText = card1.dataset.text;
        } else if (currentWords.some(w => w.en === card2.dataset.text)) {
          englishText = card2.dataset.text;
        }
        if (englishText) speakEnglish(englishText);

        matchedCount++;
        document.getElementById("matchedCount").innerText = matchedCount;

        // æœ¬å…³æ˜¯å¦ç»“æŸ
        const matchedCards = document.querySelectorAll(".matched");
        if (matchedCards.length === cards.length) {
          // å…¨éƒ¨åŒ¹é…å®Œæˆ
          setTimeout(() => {
            clearInterval(timerInterval);

            // è®°å½•åˆ°æ’è¡Œæ¦œ
            leaderboard.push({
              time: timer,
              mistakes: mistakesThisRound,
              maxCombo: maxCombo
            });
            updateLeaderboard();

            level++;
            document.getElementById("level").innerText = level;

            // å¦‚æœæ˜¯æœ€åä¸€å±€ï¼Œå®Œæˆåæ¸¸æˆç»“æŸ
            if (isFinalRound) {
              endGame();
            } else {
              setTimeout(createGameBoard, 500);
            }
          }, 400);
        }
      } else {
        // ---- åŒ¹é…å¤±è´¥ ----
        wrongSound.play();
        mistakesThisRound++;

        // è¿å‡»é‡ç½®
        combo = 0;
        document.getElementById("comboDisplay").innerText = combo;

        // ç”Ÿå‘½ -1
        lives--;
        document.getElementById("livesDisplay").innerText = lives;

        // è®°å½•é”™è¯¯
        wrongMatches[level].push({ card1: card1.dataset.text, card2: card2.dataset.text });

        card1.classList.add("wrong");
        card2.classList.add("wrong");
        setTimeout(() => {
          card1.classList.remove("selected", "wrong");
          card2.classList.remove("selected", "wrong");
        }, 400);

        // å¦‚æœç”Ÿå‘½è€—å°½ -> æ¸¸æˆç»“æŸ
        if (lives <= 0) {
          setTimeout(() => {
            clearInterval(timerInterval);
            alert("ä½ å·²ç»æ²¡æœ‰ç”Ÿå‘½äº†ï¼Œæ¸¸æˆç»“æŸï¼");

            // è®°å½•æœ¬å…³åˆ°æ’è¡Œæ¦œ
            leaderboard.push({
              time: timer,
              mistakes: mistakesThisRound,
              maxCombo: maxCombo
            });
            updateLeaderboard();

            endGame(); // æ•´ä¸ªæ¸¸æˆç»“æŸ
          }, 500);
        }
      }
      flippedCards = [];
    }

    // ====== è‹±è¯­å‘éŸ³ ======
    function speakEnglish(word) {
      let utterance1 = new SpeechSynthesisUtterance(word);
      utterance1.lang = "en-US";
      utterance1.rate = 0.9;
      speechSynthesis.speak(utterance1);

      let utterance2 = new SpeechSynthesisUtterance(word);
      utterance2.lang = "en-US";
      utterance2.rate = 0.9;
      speechSynthesis.speak(utterance2);
    }

    // ====== æ›´æ–°æ’è¡Œæ¦œ ======
    function updateLeaderboard() {
      const list = document.getElementById("leaderboardList");
      list.innerHTML = "";
      leaderboard.forEach((round, index) => {
        let li = document.createElement("li");
        li.innerText = `ç¬¬${index + 1}å…³ï¼š${round.time.toFixed(2)}ç§’ï¼Œé”™è¯¯ï¼š${round.mistakes}æ¬¡ï¼Œæœ€é«˜è¿å‡»ï¼š${round.maxCombo}`;
        list.appendChild(li);
      });
    }

    // ====== æç¤ºåŠŸèƒ½ ======
    function useHint() {
      if (hintCount <= 0) return; // æ²¡æœ‰æç¤ºæ¬¡æ•°äº†
      hintCount--;
      hintBtn.innerText = `æç¤º(${hintCount})`;
      if (hintCount <= 0) {
        hintBtn.disabled = true;
      }

      // æ‰¾åˆ°æœªåŒ¹é…çš„å¡ç‰‡
      const unmatchedCards = Array.from(document.querySelectorAll(".card"))
        .filter(c => !c.classList.contains("matched"));

      if (unmatchedCards.length < 2) return;

      shuffle(unmatchedCards);
      let foundPair = null;
      for (let i = 0; i < unmatchedCards.length; i++) {
        let cardA = unmatchedCards[i];
        let pairText = cardA.dataset.pair;
        let cardB = unmatchedCards.find(c => c.dataset.text === pairText && c !== cardA);
        if (cardB) {
          foundPair = [cardA, cardB];
          break;
        }
      }
      if (!foundPair) return;

      const [card1, card2] = foundPair;
      card1.classList.add("selected");
      card2.classList.add("selected");

      // 2ç§’åç¿»å›
      setTimeout(() => {
        card1.classList.remove("selected");
        card2.classList.remove("selected");
      }, 2000);
    }

    // ====== æ¸¸æˆç»“æŸï¼šå¼¹çª—æ˜¾ç¤ºæ‰€æœ‰å…³å¡é”™è¯¯ ======
    function endGame() {
      clearInterval(timerInterval);
      alert("ğŸ‰ æ¸¸æˆå·²ç»“æŸï¼æ€»åŒ¹é…ï¼š" + matchedCount + " ç»„å•è¯ã€‚");

      const endScreen = document.getElementById("endScreen");
      endScreen.style.display = "block";

      const summaryDiv = document.getElementById("wrongWordSummary");
      summaryDiv.innerHTML = createWrongWordTable();
    }

    // ====== ç”Ÿæˆæ‰€æœ‰å…³å¡çš„é”™è¯¯åŒ¹é…è¡¨ ======
    function createWrongWordTable() {
      let html = "";
      const allLevels = Object.keys(wrongMatches);
      const noMistakeAllGame = allLevels.every(lv => wrongMatches[lv].length === 0);
      if (noMistakeAllGame) {
        html += "<p>ä½ å¤ªæ£’äº†ï¼Œæ²¡æœ‰ä»»ä½•é”™è¯¯åŒ¹é…ï¼</p>";
        return html;
      }

      html += "<table>";
      html += "<tr><th>å…³å¡</th><th>é”™è¯¯åŒ¹é…</th></tr>";
      for (let lv of allLevels) {
        const errors = wrongMatches[lv];
        if (errors.length === 0) {
          html += `
            <tr>
              <td>ç¬¬${lv}å…³</td>
              <td>æ— é”™è¯¯</td>
            </tr>
          `;
          continue;
        }
        const errorPairs = errors.map(e => `${e.card1} - ${e.card2}`).join("; ");
        html += `
          <tr>
            <td>ç¬¬${lv}å…³</td>
            <td>${errorPairs}</td>
          </tr>
        `;
      }
      html += "</table>";
      return html;
    }

    // ====== ç»“æŸå¼¹çª— â€œå…³é—­â€æŒ‰é’® ======
    document.getElementById("endCloseBtn").onclick = () => {
      document.getElementById("endScreen").style.display = "none";
    };
	
	
	// ç»‘å®šä¸‹è½½æŒ‰é’®
	document.getElementById("downloadFileBtn").addEventListener("click", downloadFile);

	// ä¸‹è½½æ–‡ä»¶å‡½æ•°
	function downloadFile() {
		const fileName = "å•è¯æ¨¡æ¿.xlsx";  // ä½ å¯ä»¥ä¿®æ”¹è¿™ä¸ªæ–‡ä»¶å
		const fileUrl = "å•è¯æ¨¡æ¿.xlsx";  // è¿™é‡Œå¡«å†™å®é™…çš„æ–‡ä»¶è·¯å¾„

	// åˆ›å»ºä¸€ä¸ªä¸‹è½½é“¾æ¥
		const link = document.createElement("a");
	link.href = fileUrl;
	link.download = fileName;
  
  // è§¦å‘ç‚¹å‡»äº‹ä»¶ï¼Œå¼€å§‹ä¸‹è½½
  link.click();
}

  </script>
</body>
</html>
